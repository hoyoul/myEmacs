#+title: Emacs From Scratch Configuration
#+PROPERTY: header-args:emacs-lisp :tangle ./init.el :mkdirp yes

* Start!
:About_Setting:
기본적인 것을 설정한다. emacs.org는 .emac.d폴더에 넣어 둔다. 그리고 수정할때 마다, 추가할 때 마다 tangle에 의해서 자동으로 init.el이 만들어진다.
- =[ evaluation ]=
- eval-buffer
buffer 전체를 해석한다.
- C-x e
한문장을 해석한다.
- M-: 
minibuffer에서 해석한다.  현재의 mode에서 실행할 수 있는 장점이 있다.
- ns-command-modifier: command키를 meta로 한다.
- make-backup-files:  backup file을 만들지 않는다.
  - server socket directory: emacs --daemon=a라고 하면 a라는  server socket file이 해당 폴더에 저장된다.
:end:
:About_EmacsDaemon:
- (server-start)
  emacs를 실행시키면 server가 된다. frame을 닫으면 server도 stop된다. 즉 emacs화면을 유지한 상태에서 emacsclient의 접속을 받아 server의 기능을 유지한다. 우리는 화면(frame)을 닫아도 background에서 도는 daemon을 원하기 때문에 이 방법은 쓸 수 없다.
-  emacs --daemon
  emacs의 configuration을 실행한 후 daemon이 된다. background에서 계속 돈다.
  - emacs --daemon=one_daemon
    emacs daemon에 이름을 줘서 여러개의 daemon을 만들 수 있다.

- [문제]
   emacs --daemon으로 실행할 때 init.el을 실행한다. 그리고 daemon으로 동작한다. 이때 emacsclient -c로 새로운 frame을 만들고 접속할때, 이상한 frame이 만들어진다. font나 modeline이 이상하게 보여진다. 이것은 처음 만들어진 frame에서만 발생되는 현상이다. 그 이후에 frame을 만들면 정상적으로 보인다. 이것은 emacsclient -c가 first frame을 만들때 font나 modeline의 설정을 init.el에 있는것이 아닌 default값을 쓰기 때문이다. 즉 emacs daemon이 실행하면서 설정한 값들이 emacsclient -c로  실행될 때 init.el에 기술된 설정을 적용하지 않는것이다.
- [해결법]
   daemon이 init.el을 적용할때 hook을 걸어두는 것이다. frame이 만들어진 이후에 font나 modeline을 설정하게 만드는 함수를 만들고 hook을 걸어둔다. deamon이 hook을 실행하고,모든 설정을 수행한 후에 deamon을 돌고 emacsclient -c로 연결을 하면, frame이 만들어지는데 이때 hook이 실행되는 원리다. 약간 설명이 미흡한데 자세한 동작원리를 모르기 때문이다.
   
- initial-frame-alist, default-frame-alist
  frame 설정에 관련된 값들이 key,value쌍으로 저장된다. 최초의 frame관련 설정은 initial-frame-alist에 있고, default는 그 이후 만들어지는 frame에 대한 설정을 가지고 있다. 

- [emacs server 사용법]
  emacs --fd-daemon은 emacs daemon을 동작시킨다. daemon은 socket file을 가지고 있는데, 그 위치를 emacs.org설정파일에 /tmp/emacs1000/server라는 이름으로 기술되어 있다. emacsclient는 daemon에 접속하기 위해서 emacsclient -c --server-socket-name=/tmp/emacs1000/server를 기술해야만 접속이 가능하다. 

:end:

#+begin_src emacs-lisp

  (setq ns-command-modifier 'meta)
  (setq make-backup-files nil)
  (setq server-socket-dir "/tmp/emacs1000")
  (defvar holy/default-font-size 200)
  (defvar holy/default-variable-font-size 200)
#+end_src

* Package System Setup
:AboutSetting:
emacs의 package관리 시스템은 old-school인 package가 있고, modern한 use-package가 있다. use-package로 package를 관리한다. 
- package-archive
 package repo를 지정한다.
- package-archive-contents
package repo마다 가지고 있는 package 목록과 설치여부를 표시한 list
- package-initialize
package-archive-contents에 installed로 표시된 package를 설치하고 load(autoload지시자가 있는 function을 실행)한다.
- package-refresh-contents
package-archive-content를 update한다.
- use-package-always-ensure
use-package는 package를 install, load, config할 수 있는데, install을 할때 ensure:t를 해주면 package가 system에 없을 경우 down받아서 install해준다. use-package를 사용하는 모든 경우에 system설치 여부를 확인하고 없으면 install하겠다는 function이다.
:END:
#+begin_src emacs-lisp

  ;; Initialize package sources
  (require 'package)

  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                           ("org" . "https://orgmode.org/elpa/")
                           ("elpa" . "https://elpa.gnu.org/packages/")))

  (package-initialize)
  (unless package-archive-contents
    (package-refresh-contents))

    ;; Initialize use-package on non-Linux platforms
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  (require 'use-package)
  (setq use-package-always-ensure t)

#+end_src

** automatically update packages
:AboutSetting:
- upgrade, update
설치된 package를 update하려면, M-x list-package를 통해 repo에서 새로운 package content list를 다운받아서 비교를 통해서 update항목을 알려준다. U를 눌러 update를 하고 x를 눌러 실행한다. 매번 list-package로 update 유무를 판단하는것은 힘들다. 자동으로 하는 설정이다.
7일, 오전 9시에 update를 하고 하기전에 prompt로 물어보게 했다.
=NOTE=
package update는 잘못된 package를 update를 할경우 설정이 꼬일 수 있다. 그래서 안사용해도 된다.
:end:
#+begin_src emacs-lisp

(use-package auto-package-update
   :custom
   (auto-package-update-interval 7)
   (auto-package-update-prompt-before-update t)
   (auto-package-update-hide-results t)
   :config
   (auto-package-update-maybe)
   (auto-package-update-at-time "09:00"))
#+end_src
* Basic UI Configuration
:About_Setting:
- fringe-mode
 보여지는 화면의 좌우 여백(padding)을 준다고 생각하면 된다.
- do-list
do-list는 python의 for 변수 in 배열 구문으로 보면된다.
4가지 mode에는 line number를 disable하겠다는 뜻이다.
:end:
#+begin_src emacs-lisp

  (setq inhibit-startup-message t)

  (scroll-bar-mode -1)        ; Disable visible scrollbar
  (tool-bar-mode -1)          ; Disable the toolbar
  (tooltip-mode -1)           ; Disable tooltips
  (set-fringe-mode 10)        ; Give some breathing room

  (menu-bar-mode -1)            ; Disable the menu bar

  ;; Set up the visible bell
  (setq visible-bell t)

  (column-number-mode)
  (global-display-line-numbers-mode t)

  ;; Disable line numbers for some modes
  (dolist (mode '(org-mode-hook
                  term-mode-hook
                  shell-mode-hook
                  eshell-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 0))))

#+end_src
** Font Configuration
:AboutSetting:
- system에 설치되어야 하는 font는 2가지다. fixed-pitch-font(fira code; for coding), variable-pitch-font(문서작성용) 아래에서 다운받는다.
[[https://github.com/tonsky/FiraCode][Fira Code]] ,[[https://fonts.google.com/specimen/Cantarell][Cantarell]] 
- 아래 설정에 3개의 이름의 face가 설정되어 있다. default,fixed-pitch,variable-pitch 이런 이름으로 선언만 한것이다. mode에 진입하면, mode의 구성요소별로 해당 face를 선택할 수 있다. face가 없는것은 default란 이름의 face가 적용되기 때문에 대부분의 mode에서는 fira code retina 폰트로 설정될 것이다. variable-pitch-mode에서는 variable-pitch를 face로 사용하기 때문에 Cantarell로 보일 것이다.
:End:
#+begin_src emacs-lisp

     (defun holy/set-font-faces ()		
       (message "Setting faces!")
       (set-face-attribute 'default nil :font "Fira Code Retina" :height holy/default-font-size)

           ;; Set the fixed pitch face
       (set-face-attribute 'fixed-pitch nil :font "Fira Code Retina" :height holy/default-font-size)

           ;; Set the variable pitch face
       (set-face-attribute 'variable-pitch nil :font "Cantarell" :height holy/default-font-size :weight 'regular)
  )

    (if (daemonp)
        (add-hook 'after-make-frame-functions
           (lambda (frame)
                   (setq doom-modeline-icon t)
		     (message "Deamon faces!")
               (with-selected-frame frame
                    (holy/set-font-faces))))
        (holy/set-font-faces))

#+end_src

* UI Configuration
** Command Log Mode
:AboutSetting:
command-log-mode]] 는 눌려지는 key를 화면에 표시해준다. 방송을 할때 주로 많이 쓰인다.
clm/open-command-log-buffer를 실행하면 오른쪽에 buffer가 만들어지며 keybinding을 확인할 수 있다.
[[https://github.com/lewang/command-log-mode][참조]]
:end:
#+begin_src emacs-lisp
(use-package command-log-mode)
#+end_src

** Color Theme
:About_Setting:
theme는 여러 종류가 있는데, doom theme가 가장 modern하다.
[[https://github.com/hlissner/emacs-doom-themes][doom-themes]] , [[https://github.com/hlissner/emacs-doom-themes/tree/screenshots][screenshots]] 
- counsel-load-themes로 theme 둘러보기가 가능하다.
:end:
#+begin_src emacs-lisp
(use-package doom-themes
  :init (load-theme 'doom-monokai-spectrum t))
#+end_src
** Better Modeline
:About_Setting:
doom-modeline]] , [[https://github.com/seagle0128/doom-modeline#customize][configuration options]] 

*NOTE:* doom modeline은 icon이 보여지는데, 이 아이콘은 다음과 같이 설치해야 보여진다. 
`M-x all-the-icons-install-fonts` 

- doom-modeline-buffer-file-name-style
buffer에 파일 경로도 보여준다.
[[https://github.com/seagle0128/doom-modeline][모드라인]]
:end:
#+begin_src emacs-lisp

(use-package all-the-icons)

(use-package doom-modeline
  :init (doom-modeline-mode 1)
  :config (setq doom-modeline-buffer-file-name-style 'truncate-upto-project)
  :custom ((doom-modeline-height 18)))

#+end_src

** Which Key

[[https://github.com/justbur/emacs-which-key][which-key]] 
Emacs에서 keybinding을 사용해서 명령어를 실행하는데, 명령어 candidates를 minibuffer에 보여준다. 예를 들어, C-x를 누르면 명령어에 대한 candidates가 보여진다.

#+begin_src emacs-lisp

(use-package which-key
  :init (which-key-mode)
  :diminish which-key-mode
  :config
  (setq which-key-idle-delay 1))

#+end_src

** Ivy and Counsel

[[https://oremacs.com/swiper/][Ivy]] 
- completion engine, minibuffer의 candidates를 보여주는 engine이다. 위에 봤던 which-key도 ivy의 completion의 engine을 사용한다.
- =problem=
ivy completion의 문제가 있다. 예를 들어보자. C-x f(find-file)를 실행한다. test~.org라는 파일이 있다. 나는 새로운 file인 test.org를 새로 만들려고 한다. 그래서 mini buffer에 test.org를 친 후 엔터를 입력한다. test.org가 만들어지지 않고 test~.org가 열린다. 이것을 해결할려면 test다음에  C-M-j를 누르고 .org를 입력해야 한다.
[[https://github.com/Yevgnen/ivy-rich][ivy-rich]] 
- M-x를 치면 mini buffer에 candidates가 나오는게 ivy engine을 쓰기 때문이다. 

- use-package(:diminish)
modeline에 mode를 감춘다. load되는 mode가 너무 많아지면 지저분해지기 때문이다.

#+begin_src emacs-lisp

    (use-package ivy
      :diminish
      :bind (("C-s" . swiper)
             :map ivy-minibuffer-map
             ("TAB" . ivy-alt-done)
             :map ivy-switch-buffer-map
             ("C-d" . ivy-switch-buffer-kill)
             :map ivy-reverse-i-search-map
             ("C-k" . ivy-previous-line)
             ("C-d" . ivy-reverse-i-search-kill))
      :config
      (ivy-mode 1))

    (use-package ivy-rich
      :init
      (ivy-rich-mode 1))

    (use-package counsel
      :bind (("C-M-j" . 'counsel-switch-buffer)
             :map minibuffer-local-map
             ("C-r" . 'counsel-minibuffer-history))
      :config
      (counsel-mode 1))

#+end_src

** Helpful Help Commands

[[https://github.com/Wilfred/helpful][Helpful]] 
-  describe-function, describe-variable과 같은 document는 built-in package나 counsel을 통해서 보는 것은 source와 간략한 설명뿐이다. helpful package는 좀 더 자세한 help document를 제공한다.

#+begin_src emacs-lisp

  (use-package helpful
    :custom
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    ([remap describe-function] . counsel-describe-function)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . counsel-describe-variable)
    ([remap describe-key] . helpful-key))

#+end_src

** Text Scaling

 [[https://github.com/abo-abo/hydra][Hydra]] 
- hydra는 keybinding을 편리하게 해주는 package다. <f2> i key 가 increase character로 define되어 있을때 글자 크기를 키우기 위해서 <f2> i ,<f2> i , <f2> i...를 계속 눌러서 키워야 한다. 이것을 간단히 하기 위해서 hydra를 사용한다.  hydra를 사용하면 <f2> i,i,i,i...로 계속 키울수 있다. 아래에선 hydra-text-scale이란 function을 사용하고(M-x hydra..) 메뉴형식으로 보여지게 된다.
#+begin_src emacs-lisp

  (use-package hydra)

  (defhydra hydra-text-scale (:timeout 4)
    "scale text"
    ("j" text-scale-increase "in")
    ("k" text-scale-decrease "out")
    ("f" nil "finished" :exit t))

;  (rune/leader-keys
;    "ts" '(hydra-text-scale/body :which-key "scale text"))

#+end_src

* Org Mode

[[https://orgmode.org/][Org Mode]] 

** Better Font Faces
-  -<tab>을 써서 dot으로 바꾸는 것은 regular expression을 사용한다.
- org mode에서 header는 org-level-1,2,3,...으로 나타낸다. 각각의 header의 size를 설정하고 Cantarell이라는 가변폰트를 사용해서 face를 정의한다.
- code나 table의 경우는 고정폰트로 face를 정의한다.

#+begin_src emacs-lisp

  (defun holy/org-font-setup ()
    ;; Replace list hyphen with dot
    (font-lock-add-keywords 'org-mode
                            '(("^ *\\([-]\\) "
                               (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

    ;; Set faces for heading levels
    (dolist (face '((org-level-1 . 1.2)
                    (org-level-2 . 1.1)
                    (org-level-3 . 1.05)
                    (org-level-4 . 1.0)
                    (org-level-5 . 1.1)
                    (org-level-6 . 1.1)
                    (org-level-7 . 1.1)
                    (org-level-8 . 1.1)))
      (set-face-attribute (car face) nil :font "Cantarell" :weight 'regular :height (cdr face)))

    ;; Ensure that anything that should be fixed-pitch in Org files appears that way
    (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-table nil   :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch))

#+end_src

** Basic Config

강의: [[https://youtu.be/VcgjTEa0kU4][Part 5]] and [[https://youtu.be/PNE-mgkZ6HM][Part 6]] 

[org mode setup]

- org file을 open하면, org-mode라는 function이 수행된다.  아래에서 use-package org도 org-mode를 수행한다고 보면된다.
- org-indent-mode:indent는 말그대로 org mode에서는 indentation을 하겠다는 뜻이다. 새로운 줄이 시작될때 띄어쓰기가 된다.
- varible-pitch-mode:org파일을 가변폰트로 쓰겠다는 뜻이다.
- visual-line-mode: line이 끝날때 word wrapping으로 line이 끝난다.

[org agenda]
- org-agenda-start-log-mode
- org-log-done 'time
- org-log-into-drawer(org-add-note)

agenda는 todo header를 뜻한다. agenda가 끝나면, 끝났다는 것을 기록하고 agenda view에서 볼때 언제 끝난지 표시될 수 있어야 한다. org-log-done은 끝나는 시간을 todo header에 표시해주고, start-log-mode를 true로 하면 agenda view에서 끝난시간이 기록되어 볼 수 있다. org-log-into-drawer는 agenda에 drawer를 만든다. drawer라는것은 서랍인데 agenda와 관련한 내용을 작성하고 서랍에 넣는다고 보면된다. org mode에서 header들은 tab키로 열고 닫을수 있다. header가 아닌면서 열고 닫는 기능을 갖는 게 drawer다. C-c C-z를 누르면 quick note를 작성하는데 작성이 끝난것을 org-log-into-drawer가 t로 되어 있으면 LOGBOOK이 만들어지면서, quick note가 저장된다

- org-agenda-files
agenda view에서 보기 위해선 agenda들이 기록될 파일들이 특정위치에 있어야 한다.

- org-habit
org-modules중에 org-habit이 enable되어야 한다.

#+begin_src emacs-lisp

  (defun holy/org-mode-setup ()
    (org-indent-mode)
    (variable-pitch-mode 1)
    (visual-line-mode 1))

  (use-package org
    :hook (org-mode . holy/org-mode-setup)
    :config
    (setq org-ellipsis " ▾")

    (setq org-agenda-start-with-log-mode t)
    (setq org-log-done 'time)
    (setq org-log-into-drawer t)

    (setq org-agenda-files
          '("~/MyWorld/Projects/OrgFiles/Tasks.org"
            "~/MyWorld/Projects/OrgFiles/Habits.org"
         "~/MyWorld/Projects/OrgFiles/Birthdays.org"))

    (require 'org-habit)
    (add-to-list 'org-modules 'org-habit)
    (setq org-habit-graph-column 60)

    (setq org-todo-keywords
      '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
        (sequence "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(v)" "WAIT(w@/!)" "HOLD(h)" "|" "COMPLETED(c)" "CANC(k@)")))

    (setq org-refile-targets
      '(("Archive.org" :maxlevel . 1)
        ("Tasks.org" :maxlevel . 1)))

    ;; Save Org buffers after refiling!
    (advice-add 'org-refile :after 'org-save-all-org-buffers)

    (setq org-tag-alist
      '((:startgroup)
         ; Put mutually exclusive tags here
         (:endgroup)
         ("@errand" . ?E)
         ("@home" . ?H)
         ("@work" . ?W)
         ("agenda" . ?a)
         ("planning" . ?p)
         ("publish" . ?P)
         ("batch" . ?b)
         ("note" . ?n)
         ("idea" . ?i)))

    ;; Configure custom agenda views
    (setq org-agenda-custom-commands
     '(("d" "Dashboard"
       ((agenda "" ((org-deadline-warning-days 7)))
        (todo "NEXT"
          ((org-agenda-overriding-header "Next Tasks")))
        (tags-todo "agenda/ACTIVE" ((org-agenda-overriding-header "Active Projects")))))

      ("n" "Next Tasks"
       ((todo "NEXT"
          ((org-agenda-overriding-header "Next Tasks")))))

      ("W" "Work Tasks" tags-todo "+work-email")

      ;; Low-effort next actions
      ("e" tags-todo "+TODO=\"NEXT\"+Effort<15&+Effort>0"
       ((org-agenda-overriding-header "Low Effort Tasks")
        (org-agenda-max-todos 20)
        (org-agenda-files org-agenda-files)))

      ("w" "Workflow Status"
       ((todo "WAIT"
              ((org-agenda-overriding-header "Waiting on External")
               (org-agenda-files org-agenda-files)))
        (todo "REVIEW"
              ((org-agenda-overriding-header "In Review")
               (org-agenda-files org-agenda-files)))
        (todo "PLAN"
              ((org-agenda-overriding-header "In Planning")
               (org-agenda-todo-list-sublevels nil)
               (org-agenda-files org-agenda-files)))
        (todo "BACKLOG"
              ((org-agenda-overriding-header "Project Backlog")
               (org-agenda-todo-list-sublevels nil)
               (org-agenda-files org-agenda-files)))
        (todo "READY"
              ((org-agenda-overriding-header "Ready for Work")
               (org-agenda-files org-agenda-files)))
        (todo "ACTIVE"
              ((org-agenda-overriding-header "Active Projects")
               (org-agenda-files org-agenda-files)))
        (todo "COMPLETED"
              ((org-agenda-overriding-header "Completed Projects")
               (org-agenda-files org-agenda-files)))
        (todo "CANC"
              ((org-agenda-overriding-header "Cancelled Projects")
               (org-agenda-files org-agenda-files)))))))

    (setq org-capture-templates
      `(("t" "Tasks / Projects")
        ("tt" "Task" entry (file+olp "~/MyWorld/Projects/OrgFiles/Tasks.org" "Inbox")
             "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)

        ("j" "Journal Entries")
        ("jj" "Journal" entry
             (file+olp+datetree "~/MyWorld/Projects/OrgFiles/Journal.org")
             "\n* %<%I:%M %p> - Journal :journal:\n\n%?\n\n"
             ;; ,(dw/read-file-as-string "~/Notes/Templates/Daily.org")
             :clock-in :clock-resume
             :empty-lines 1)
        ("jm" "Meeting" entry
             (file+olp+datetree "~/MyWorld/Projects/OrgFiles/Journal.org")
             "* %<%I:%M %p> - %a :meetings:\n\n%?\n\n"
             :clock-in :clock-resume
             :empty-lines 1)

        ("w" "Workflows")
        ("we" "Checking Email" entry (file+olp+datetree "~/MyWorld/Projects/OrgFiles/Journal.org")
             "* Checking Email :email:\n\n%?" :clock-in :clock-resume :empty-lines 1)

        ("m" "Metrics Capture")
        ("mw" "Weight" table-line (file+headline "~/MyWorld/Projects/OrgFiles/Metrics.org" "Weight")
         "| %U | %^{Weight} | %^{Notes} |" :kill-buffer t)))

    (define-key global-map (kbd "C-c j")
      (lambda () (interactive) (org-capture nil "jj")))

    (holy/org-font-setup))

#+end_src

*** Nicer Heading Bullets

- 참조
[[https://github.com/sabof/org-bullets][org-bullets]] , [[https://github.com/integral-dw/org-superstar-mode][org-superstar-mode]] 

- 헤더의 level을 나타냄.

#+begin_src emacs-lisp

  (use-package org-bullets
    :after org
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))

#+end_src

*** Center Org Buffers

참조:  [[https://github.com/joostkremers/visual-fill-column][visual-fill-column]] 
- org mode의 양 side에 padding을 붙인다. text는 center로 가게 한다.
#+begin_src emacs-lisp

  (defun holy/org-mode-visual-fill ()
    (setq visual-fill-column-width 100
          visual-fill-column-center-text t)
    (visual-fill-column-mode 1))

  (use-package visual-fill-column
    :hook (org-mode . holy/org-mode-visual-fill))

#+end_src

** Configure Babel Languages

참조:  [[https://orgmode.org/worg/org-contrib/babel/languages.html][This page]] 
- literate programming을 할수 있다.  babel을 하기 위해선, 여기에 programming language를 등록도 하고, 해당되는 elisp package도 설치해야 하고, system에 interpreter나 compiler가 설치 되어 있어야 한다.

#+begin_src emacs-lisp

  (org-babel-do-load-languages
    'org-babel-load-languages
    '((emacs-lisp . t)
      (python . t)))

  ;; (push '("conf-unix" . conf-unix) org-src-lang-modes)

#+end_src
** Structure Templates
- 참고
 [[https://orgmode.org/manual/Structure-Templates.html][structure templates]] , [[https://orgmode.org/worg/org-contrib/babel/languages.html][as it is known by Org Babel]].
<sh<tab> 을 누르면 template이 써진다.
#+begin_src emacs-lisp

  ;; This is needed as of Org 9.2
  (require 'org-tempo)

  (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("py" . "src python"))

#+end_src

** Auto-tangle Configuration Files
- tangle
tangle이라는 것은 src_block에 기술한것을 특정 파일에 쓰는 것을 뜻한다. 여기서는 emacs.org라는 파일에서 emacs에 대한 설정을 src_block에 한다. 그런 다음 org-babel-tangle이라는 명령을 사용해서 최상단에 지정된 init.el로 쓰는 작업을 하게 된다.

#+begin_src emacs-lisp
  ;; Automatically tangle our Emacs.org config file when we save it
  (defun holy/org-babel-tangle-config ()
    (when (string-equal (buffer-file-name)
                        (expand-file-name "~/MyWorld/emacs.org"))
      ;; Dynamic scoping to the rescue
      (let ((org-confirm-babel-evaluate nil))
        (org-babel-tangle))))

  (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'holy/org-babel-tangle-config)))
#+end_src

* Development
** Languages
*** Language Servers

#+begin_src emacs-lisp
(defun holy/lsp-mode-setup ()
  (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
  (lsp-headerline-breadscrumb-mode))

(use-package lsp-mode
  :commands (lsp lsp-deferred)
  :hook (lsp-mode . holy/lsp-mode-setup)
  :init
  (setq lsp-keymap-prefix "C-c l")
  :config
  (lsp-enable-which-key-integration t))
#+end_src
*** TypeScript
#+begin_src emacs-lisp
  (use-package typescript-mode
    :mode "\\.ts\\'"
    :hook (typescript-mode . lsp-deferred)
    :config
    (setq typescript-indent-level 2))

#+end_src
** Projectile

- 참조
[[https://projectile.mx/][Projectile]] 
- project를 관리하는 app, project가 위치할 곳을 정해두고 거기서 project를 생성해야 처리가 된다.
- projectile-rg
가장 많이 사용하는 grep인데, system에 ripgrep을 설치하고 사용한다.

#+begin_src emacs-lisp

  (use-package projectile
    :diminish projectile-mode
    :config (projectile-mode)
    :custom ((projectile-completion-system 'ivy))
    :bind-keymap
    ("C-c p" . projectile-command-map)
    :init
    ;; NOTE: Set this to the folder where you keep your Git repos!
    (when (file-directory-p "~/MyWorld/Projects/Code")
      (setq projectile-project-search-path '("~/MyWorld/Projects/Code")))
    (setq projectile-switch-project-action #'projectile-dired))

  (use-package counsel-projectile
    :config (counsel-projectile-mode))

#+end_src
** Terminal 
***   terminal
vterm을 추천한다.
#+begin_src emacs-lisp
(use-package term
  :config
  (setq explicit-shell-file-name "zsh")
  (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *"))

(use-package eterm-256color
  :hook (term-mode . eterm-256color-mode))

#+end_src
*** Vterm
- vterm은 emacs native terminal이라서 빠르다.
- vterm을 사용하기 위해선, system에 cmake가 설치되어 있어야 한다. (brew install cmake libtool)
#+begin_src emacs-lisp
(use-package vterm
  :commands vterm
  :config
  (setq vterm-max-scrollback 10000))
#+end_src
** Shell
eshell을 추천한다.
#+begin_src emacs-lisp
  (defun holy/configure-eshell ()
    (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)
    (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

    (setq eshell-history-size                    10000
	   eshell-buffer-maximum-lines 10000
	   eshell-hist-ignoredups t
	   eshell-scroll-to-bottom-on-input t))

  (use-package eshell-git-prompt)

  (use-package eshell
    :hook (eshell-first-time-mode . holy/configure-eshell)
    :config
    (with-eval-after-load 'esh-opt
       (setq eshell-destroy-buffer-when-process-dies t)
       (setq eshell-visual-commands '("htop" "zsh" "vim" "less" "more")))
    (eshell-git-prompt-use-theme 'powerline))

#+end_src
** Magit
- 참조
[[https://magit.vc/][Magit]] 
- forge
forge는 github과의 연동을 위해서 사용한다고 한다.
- magit-branch-read-upstream-first 'fallback
magit에서 branch를 만드는 명령어가 안된다. 되게 해주는 setting
#+begin_src emacs-lisp

  (use-package magit
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

  ;; NOTE: Make sure to configure a GitHub token before using this package!
  ;; - https://magit.vc/manual/forge/Token-Creation.html#Token-Creation
  ;; - https://magit.vc/manual/ghub/Getting-Started.html#Getting-Started
  (use-package forge)

(setq magit-branch-read-upstream-first 'fallback)
#+end_src

** Rainbow Delimiters

- 참조
[[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] 
parenthesis topology를 color별로 나타낸다.
#+begin_src emacs-lisp

(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))

#+end_src

* File Management
- ^, dired-jump(C-x j)
상위폴더로 이동, dired-jump는 현재 buffer에서 dired mode로 전환한다.
- C-o (dired-display-file)
파일을 other window에서 open
- dired-listing-switch
listing을 sorting한다. directory 먼저 나오고 그다음 file
- dired-hide-detail( open parenthesis )
파일 이름만 나오게 한다.
- dired-toggle-marks
하나의 파일을 m을 눌러 mark한 후 t를 누르면 mark된 파일 빼놓고 모든 파일이 mark된다.
- dired-mark-files-regex
%키를 누르면 sub menu가 나온다. m(dired-mark-files-regex)을 선택하고 원하는 파일의 패턴을 입럭한다. 
예를 들면, .org$; 이것은 org로 끝나는 파일을 의미한다.
- *
sub menu가 보이고 조건에  맞는 파일을 mark한다.
- =[copy & rename & move]=
  - c 
    copy single file
  - C
    copy multiple marked file
  .R (rename & move)
   rename 할 이름을 입력한다.
   rename할 이름을 minibuffer에 입력할때, 원하는 폴더로 이동해서 enter를 치면 move가 된다. 

- =[ dred-dwim-target ]=
이 변수를 true로 setting하면 dwim을 사용할 수 있다. 예를 들어 dired buffer를 2개를 띄운 다음 copy를 하기 위해 C를 누르면 target의 위치가 열려진 direed buffer로 정해진다. target의 위치를 따로 정할 필요가 없다. 이런 것을 dwim이라고 한다. 

- =[zip,unzip]=
가장 유용한 기능중 하나. 파일을 선택하고 Z를 누르면 zip,unzip할 수 있다. 확장자는 tar.gz다.
만일 zip으로 압축하고 싶다면,
- dired-compress-files-alist의 값을 zip으로 하면 된다. 사용법은 describe-variable에서 살펴보면 된다.

- =[other useful,helpful]=
- shift-M
 file mode변경
- shift-t
=> 파일의 timestamp를 변경할 수 있다.
- shift-o
 파일의 owner를 변경
- shift-g
=>파일의 group을 변경
- shift-s
=> symbolic link를 만든다.

- =[all-the-icons-dired-mode]=
=> dired모드에 icon

- =[dired-open]=
=> dired mode에서 선택된 파일은 emacs내에서 처리한다. 외부 프로그램에서 처리하게 할 때 이 package를 설치하고 &를 누르면 외부 프로그램을 사용할 수 있다.
예를 들어, html=>browser, png=> adobe, mp3=>mpv

- dired-listing-switches
이것은 dired에서 sorting해서 보여주는 설정인데, mac에서는 ls란 utility가 전체 설치가 안되어 있어서 동작하지 않는다. 이것을 사용하기 위해선 brew install coreutils를 설치해야 agho라는 option을 처리할 수 있다. 또한 다른것도 처리해야 하는데, 나는 그냥 안쓰기로 했다.

- =[dired-maybe-insert-subdir]=
매우 유용한 명령어, i key와 binding되어 있는데, subfolder를 볼때 새 버퍼를 띄우지 않는다. 하나의 buffer에서 subdir을 계속 보여줄 수 있다. 매우 유용한 명령어다.
** Dired
#+begin_src emacs-lisp
  (use-package dired
  :ensure nil
  :commands (dired dired-jump)
  :bind (("C-x C-j" . dired-jump))
  ;; :custom ((dired-listing-switches "-agho --group-directories-first"))
  )

  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode))

  ;; (use-package dired-open
  ;;   :config
  ;;   (add-to-list 'dired-open-functions #'dired-open-xdg t)
  ;;   (setq dired-open-extensions '(("png" . "feh")
  ;;                                 ("mkv" . "mpv"))))

  (use-package dired-hide-dotfiles
     :hook (dired-mode . dired-hide-dotfiles-mode)
     :config 
     (define-key dired-mode-map "H" 'dired-hide-dotfiles-mode))
#+end_src
* Applications
** email(Mu4e)
:LOGBOOK:
- Note taken on [2021-05-13 Thu 09:30] \\
  - [Gmail]과 imap동기화의 문제점
  Gmail은 mail을 folder로 관리하지 않는다. label로 관리한다. 오직 All Mails라는 하나의 폴더만 있는것 같다. mail이 들어오면 inbox라는 tag를 메일에 붙인다. 그리고 필요에 따라  important, starred,snoozed...같은  tag를 붙일 수 있다.  하나의 메일에는 여러개의 tag가 붙을 수 있는 것이다. 이것은  마치 하나의 메일이 여러개의 폴더에 있는 것과 같은 효과를 준다. 근데 이게 imap을 사용할 때 문제가 된다. imap은 폴더로 관리하고 각 메일은 한개의 folder에만 있기 때문이다. 그래서 gmail과 imap을 동기화하기란 쉽지 않다.
  
  - All Mail에 대해서(Archiving)
  다른 mail server들은 mail을 폴더별로 관리해서 들어오는 mail은 inbox에 넣는다. filtering해서 spam은 spam폴더에, inbox에서 버리는 메일은 trash폴더에, 메일을 작성하다가 그만두면 draft라는 폴더에, 메일을 보내면 sent 폴더에 넣는다. 그런데 gmail에는 다른곳에 없는 All Mails라는 폴더가 있다. 그리고 inbox, sent,draft...같은 것들은 그냥 label이다. 즉 메일이 중복해서 존재한다. inbox에 있는 mail은 All Mails라는 곳에도 있고, sent에 있는 mail도 All Mails, important,snooze,사용자가 만든 label에도 있는 것이다.
  
  - [imap과 Gmail]을 어떻게 동기화 할것인가?
  Gmail에서 email은 모두 label로 관리된다. 반면 imap은 폴더로 관리된다. Gmail에서는 하나의 email이 여러개의  label에 있을 수 있지만, imap은 하나의 folder에만 있게 된다. 이를 관리방법이 다른 이 두개를 어떻게 동기화 하고 사용할 것인가?
  1) [Gmail 기준으로 관리하자]- label을 폴더로 관리하자.
  즉 gmail의 label을 imap의 폴더로 mapping하는 것이다. gmail에서 메일을 작성하고, 보내고, 받고 할때 모든 mail은 label되서 관리된다. email을 보내면 sent라는 label,All mails에서 볼수 있다. important label도 붙였다면 important label에서도 볼 수 있다. 이것을 그대로 imap으로 가져오면 important 폴더, All mails폴더,sent라는 폴더에는 동일한 email이 있을 것이다. imap이 단지 보기만 한다면 이건 문제 없다. 근데 imap에서 mail을 작성해서 보낸다면, sent라는 폴더에만 email이 있을 것이다. 이것을 동기화 하면 gmail에서는 sent에만 있고, all mails에는 없는 현상이 발생한다. 이렇게 되면 gmail에서 보기 너무 힘들어버린다. 또한 imap에서는 중복된 email이 너무 많아진다.
  
  2) [imap 기준으로 관리하자] - All mails, trash,spam만을 가져오자.
  gmail에서 모든 mail은 3가지중에 하나다. spam이던가,trash이던가, all mails(archive)이던가... spam은 all mails에서 보이지 않는다. trash에서도 보이지 않는다. 이것을 imap에서 폴더로 만들어서 관리하는 것이다. imap과 동기화하면 gmail의 모든 mail이 imap에 오는것을 보장한다. 대신 gmail에서는 labeling으로 email을 관리하지 않을 것이다. imap에서 mail을 보낼경우, 보낸메일은 어디로 저장하는가? 선택할 수 있는건, All mails와 spam,trash인데, All mails로 할 수 밖에 없다. 그런데 이렇게 하면 gmail에서 내가 보낸 메일을 확인할때 all mails로 봐야 하는데, 이게 보낸 메일인지 받은메일인지 구분할 수가 없다.
  
  3) [Imap과 Gmail을 조합해서 관리하자]
  동기화할 폴더를 All Mails, Sent,draft, trash, spam으로 정하자. Gmail에선 Sent,draft 메일들은 모두 All mails에 있다. 그럼 imap으로 다운하면 중복되는 email이 있을 것이다. 하지만 imap을 사용할때는 편리하다. 받은 메일은 All mails에서 확인하면 되고, 메일을 작성하다가 멈췄을때는 draft로 보내고 보낸 메일은 sent로 보내면 imap과 gmail에서 공통적으로 사용하는 폴더와 label이기 때문에 문제 될 것이 없다. 단점은 2가지 정도 된다. 첫 번째로 imap에서 mail이 중복되는 문제, 두 번째로 imap에서 메일을 보내면 sent에 저장된다. 그리고 sent에 있던건 gmail의 sent에 동기화 된다. 따라서 gmail에서 보면 All mails에는 보낸 메일이 보이지 않는다는 것이다. 반면 gmail에서 mail을 보내면 sent와 All mails에 있고 동기화 하면 imap에서는 All mails와 sent에 둘다 있게 되는 것이다. imap으로 볼때 어떤 mail은 sent에도 있고 All mails에도 있고, 어떤건 sent에만 있는것을  확인할 수 있다. 또한 gmail에서 볼때도 어떤 mail은 sent에도 있고 All mails에도 있고, 어떤건 sent에만 있는것을 확인할 수 있다. 하지만, 이것은 감내해야 할듯 하다.
- Note taken on [2021-05-12 Wed 02:31] \\
  다음과 같은 에러가 발생할 수 있다.
  IMAP command 'AUTHENTICATE PLAIN <authdata>' returned an error: NO [AUTHENTICATIONFAILED] Invalid credentials (Failure)
  Authentication Error는 ID와 PW가 제대로 기술이 안되어 있을경우, 혹은 gmail server에서 web browser가 아닌 3rd party app에서 접근하는것을 막았을경우에 발생한다. 이 경우는 gmail에서 mail이 전송된다. 메일에 있는 link를 누르면, less secure app access를 turn on시킬수 있다. 이렇게 하면 접근이된다.
- Note taken on [2021-05-11 Tue 19:52] \\
  RSA통신: public key와 private key를 사용해서 서로간의 통신을 하기 위해서는 한쪽이 public key를 보내야 한다. 그러기 위해서 인증서에 public key를 넣어서 보낸다.  이런 통신을 이용하는 경우는 대표적으로 gmail과 같은 mail provider가 해당한다. 
  gmail 통신방법:  client와 gmail은 ssl을 사용한 imap이나 pop을 사용해서  mail을 down받거나 보내는 작업을 한다. server에 해당하는 gmail이 public key와 private key를 만든다. public key를 이용해서 인증서도 만든다. client가 gmail에 연결을 시도해서 인증서를 다운받고 받은  그 다음 부터 gmail의 public key를 사용해서 통신한다.
  
  gmail의 인증서를 얻는 방법:
  $ mkdir ~/.cert
  $ openssl s_client -connect some.imap.server:port -showcerts 2>&1 < /dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' | sed -ne '1,/-END CERTIFICATE-/p' > ~/.cert/some.imap.server.pem
  
  github 통신방법: 사용자가 public key와 private key를 만든다. public key를 github에 넣어두고 통신한다.
- Note taken on [2021-05-11 Tue 18:40] \\
  SSL: SSL은 secure socket layer다. 예전에는 tcp+ip를 사용하는 socket으로 programming해서 통신을 했다. secure socket은 이 tcp+ip에 보안요소를 곁들인 계층 혹은 socket으로 보면 된다. 흔히 우리는 domain 주소를 실제 주소로 비유하고, dns서버는 주소를 입력하면 전화번호를 알려주는 기능을 하고, tcp+ip에서는 전화번호로 통신한다고 말한다.  ip주소가 server의 전화번호이고, port가 내선번호라고 한다. 이렇게 전화번호와 내선번호로 통화를 하면 도청의 위험이 있어서 전화내용을 암호화할 필요가 생겼다. 그래서 생긴게 SSL이다. SSL은 전화걸기 전에 우선 상대방의 공개키를 내가 알고 있던지 아니면, 나의 공개키를 상대방한테 줘야 한다. 그래서 받은 공개키를 통해서 암호화해서 통신을 한다.
  
  인증서: 공개키를 상대방한테 보낼때 단지 key만 보내면 안된다. 예를들어, 국세청에서 저희하고 통신할려면 저희 공개키를 보낼테니 그걸로 암호화해서 보내세요.납세자에게 보냈다고 하자. 납세자는 국세청인줄 믿고 암호화해서 서로 메일이나 chat을 하면 안된다. 해커가 자신의 공개키를 국세청의 공개키라고 속일수 있기 때문이다. 그래서 인증서는 공개키가 국세청의 공개키가 맞다는 것을 보장해준다.
- Note taken on [2021-05-11 Tue 17:03] \\
  GPG: RSA방식의 암호화를 사용하게 해주는 tool이다. 2개의 key를 만든다. 공개키와 비밀키인데,  단순하게 열쇠와 자물쇠 2개를 만든다고 보면 된다. 통신하게 될 2개의 당사자들은 비밀키와 공개키를 이용해서 통신한다고 보면 된다. 옛날의 암호화 방식이나, password방식은 일종의 server가 password파일 목록을 가지고 있고 사용자가 입력한 password가 맞는지 안맞는지 서버에서 판단했다. 이것은 현관문의 door key와 비슷하다. 출입하는 사람은 비밀번호를 입력하고 문에는 비밀번호 목록을 가지고 있는 방식이다. 반면에 RSA는 개개인이 열쇠와 자물쇠를 모두 만들어서 자물쇠를 주는 방식이다. 그런데 둘다 key라고 부르는 이유는 둘다 암호화 복호화에 사용되는 key로 동작하기 때문이다. private key로 암호화하면 public key로 해독하고 public key로 암호화하면 private key로 복호화 한다.
:END:
:설정:
- [X] isync 설치
local에서 gmail과 sync를 할 프로그램을 설치한다. brew install isync
- [X] ~/.mbsyncrc를 설정한다. 여길 [[file:~/.mbsyncrc][참조]]
  - 여기서 passCmd와 certificateFile은 설명이 필요하다.
  - pass는 password를 직접기록한다. passCmd는 직접기록하는 대신에 명령어를 입력한다. 
    명령어는 textfile에 password를 입력해서 저장한 후 cat명령으로 읽는 방식으로도 할수 있고 gpg로 encrypt시킨 후에 decrypt하는 명령어를 넣을 수도 있다. 간단히 난 cat방식을 사용했다.
    ex) "cat ~/.oh-no-insecure-password"
    ex) gpg --quiet --for-your-eyes-only --no-tty --decrypt ~/.passwords/gmail.gpg
    - 인증서는 logbook에 적었는데, openssl을 통해서 gmail에 접속하면 gmail의 public key가 담긴 인증서를 얻을 수 있다. 얻은 인증서를 저장한 후 적용하면 된다. 
    - setting과정에서 접속문제가 발생하는데, LOGBOOK을 참조해서 해결한다.
      - two pass 인증이 아니면 less secure app을 turn on 시키면 되는 문제다. 여길 [[https://myaccount.google.com/lesssecureapps?pli=1&rapt=AEjHL4NRy2QurRqh0BmU3kcdUfG5G4FrcX8MFp2C_kRTSr_DuaGgZbVKURKyX--wvaGaMyzfuHpm8JM_II814KIMzJzDK11oEw][참조]]
      - two pass인증 에러는 Application-specific password required란 에러나 나온다.
    - maildir은 All mails, sent, draft,trash를 동기화한다.
- [X] gmail setting을 한다. 여길 [[https://support.google.com/mail/answer/7126229?hl=en][참조]]
  [label settings]
  - label에선 imap에선 all mails,sent,draft,trash만 list에 보이게 하고, imap에서도 그것만 보이게 한다.
  [imap pop settings]
  - Imap을 enabled한다.
  - “Auto-expunge off”
  - “Move the message to the trash”
- [X] mbsync -a 를 실행한다. 
  - ~/Mails/폴더에 가서 [Gmail]Sent Mail, [Gmail]Drafts...와 같은 폴더가 있는지 확인해 본다.
- [X] mu를 설치한다. (brew install mu)
  - mu를 system에 설치하면, mu4e도 설치가 된다. emacs에서 mu4e를 load할때는 아래 path를 사용해서 load한다.
- [X] mu init를 실행(mu init --maildir=~/Mail --my-address=holy.frege@gmail.com)
- [X] mu index를 실행
  - index는 sorting한다고 보면 된다.  xapian이란 db를 사용하기 때문이다.
- [X] mu4e를 설치한다.(emacs에서 mu4e는 system에서 mu를 설치하면 mu4e가 설치된다.) 그리고 이미 설치된 mu4e를  설정한다.
  - 설치할 때 mu4e-meta.el이 newer than oldfile이라고 나오면 해당 load-path로가서 mu4e-meta.elc를 지우고 다시 byte compile한다.
  - 10분마다 자동 sync하기로 했다.
  - mu4e [[https://www.djcbsoftware.nl/code/mu/mu4e/index.html][공식문서]]
- [X] mu4e 실행
  - j o 를 누르고 maildir에서 [Gmail]/Sent Mail, [Gmail]Drafts, [Gmail]Trash,[Grmail]/All mails 이외의 것이 있나 확인한다. 왜냐면 우리는 imap에서 이 4개의 폴더로 email을 관리하고 이 폴더들이 gmail과 동기화해서 web에서 gmail을 볼때 보여야 하기 때문이다.

  - C-c C-u: mbsync -a를 실행해서 update여부를 확인한다. mu4e main화면에 u를 눌러도 된다.
- [X] Mu4e context(account) 설정

:END:
#+begin_src emacs-lisp
  (use-package mu4e
    :ensure nil
    ;; :defer 20
    ;; :load-path "/usr/local/share/emacs/site-lisp/mu/mu4e/"
    ;; brew를 사용한 경우 아래에 있다.
    :load-path "/usr/local/Cellar/mu/1.4.15/share/emacs/site-lisp/mu/mu4e/"
    ;; :defer 20 ; Wait until 20 seconds after startup
    :config
    (require 'mu4e-org)
    (setq org-agenda-files '("~/org/Mail.org"))

    (setq mail-user-agent 'mu4e-user-agent)
    ;; This is set to 't' to avoid mail syncing issues when using mbsync
    (setq mu4e-change-filenames-when-moving t)
    ;; Refresh mail using isync every 10 minutes
    (setq mu4e-update-interval (* 10 60))
    (setq mu4e-get-mail-command "mbsync -a")
    (setq mu4e-maildir "~/Mail")

    (setq message-send-mail-function 'smtpmail-send-it)


    (setq mu4e-contexts
       (list
       ;; Work account
       (make-mu4e-context
        :name "public_mail"
        :match-func
          (lambda (msg)
            (when msg
              (string-prefix-p "/Gmail" (mu4e-message-field msg :maildir))))
        :vars '((user-mail-address . "holy.frege@gmail.com")
                (user-full-name    . "Holy Frege work_mail")
                (smtpmail-smtp-server  . "smtp.gmail.com")
                (smtpmail-smtp-service . 465)
                (smtpmail-stream-type  . ssl)
                (mu4e-compose-signature .
                (concat 
                     "Holy Frege \n\n"
                     "seize the time\n"
                     "test signature\n"))
                (mu4e-drafts-folder  . "/Gmail/[Gmail]/Drafts")
                (mu4e-sent-folder  . "/Gmail/[Gmail]/Sent Mail")
                (mu4e-refile-folder  . "/Gmail/[Gmail]/All Mail")
                (mu4e-trash-folder  . "/Gmail/[Gmail]/Trash")))

       ;; Personal account
       (make-mu4e-context
        :name "Private_mail"
        :match-func
          (lambda (msg)
            (when msg
              (string-prefix-p "/Fastmail" (mu4e-message-field msg :maildir))))
        :vars '((user-mail-address . "holy_frege@fastmail.com")
                (user-full-name    . "Holy Frege Personal_mail")
                (smtpmail-smtp-server  . "smtp.fastmail.com")
                (smtpmail-smtp-service . 465)
                (smtpmail-stream-type  . ssl)
                (mu4e-compose-signature .
                (concat 
                     "Holy Frege \n\n"
                     "grap the time\n"
                     "test2 signature\n"))
                (mu4e-drafts-folder  . "/Fastmail/Drafts")
                (mu4e-sent-folder  . "/Fastmail/Sent")
                (mu4e-spam-folder  . "/Fastmail/Spam")
                (mu4e-refile-folder  . "/Fastmail/Archive")
                (mu4e-trash-folder  . "/Fastmail/Trash")))))

   (setq org-capture-templates
     `(("m" "Email Workflow")
       ("mf" "Follow Up" entry (file+olp "~/org/Mail.org" "Follow Up")
          "* TODO Follow up with %:fromname on %a\nSCHEDULED:%t\nDEADLINE:    %(org-insert-time-stamp (org-read-date nil t \"+2d\"))\n\n%i"  :immediate-finish t)
       ("mr" "Read Later" entry (file+olp "~/org/Mail.org" "Read Later")
          "* TODO Read %:subject\nSCHEDULED:%t\nDEADLINE: %(org-insert-time-stamp (org-read-date nil t \"+2d\"))\n\n%a\n\n%i"  :immediate-finish t)))

   (defun holy/capture-mail-follow-up (msg)
      (interactive)
      (call-interactively 'org-store-link)
      (org-capture nil "mf"))

   (defun holy/capture-mail-read-later (msg)
      (interactive)
      (call-interactively 'org-store-link)
      (org-capture nil "mr"))

      ;; Add custom actions for our capture templates
   (add-to-list 'mu4e-headers-actions
       '("follow up" . holy/capture-mail-follow-up) t)
   (add-to-list 'mu4e-view-actions
       '("follow up" . holy/capture-mail-follow-up) t)
   (add-to-list 'mu4e-headers-actions
       '("read later" . holy/capture-mail-read-later) t)
   (add-to-list 'mu4e-view-actions
       '("read later" . holy/capture-mail-read-later) t)

   (setq mu4e-maildir-shortcuts
    '((:maildir "/Gmail/Inbox"    :key ?i)
      (:maildir "/Gmail/[Gmail]/Sent Mail" :key ?s)
      (:maildir "/Gmail/[Gmail]/Trash"     :key ?t)
      (:maildir "/Gmail/[Gmail]/Drafts"    :key ?d)
      (:maildir "/Gmail/[Gmail]/All Mail"  :key ?a))))
      ;; run mu4e in the background to sync mail periodically
    ;; (mu4e t)  
    ;; (setq user-mail-address "holy.frege@gmail.com")
    ;; (setq smtpmail-default-smtp-server "smtp.gmail.com")
    ;; (setq smtpmail-smtp-server "smtp.gmail.com")
    ;; (setq smtpmail-smtp-service 587))

#+end_src
:smtp설정:
- 설정에 대한 story
gmail, fastmail 모두 smtp를 지원한다. server, service(port), stream(ssl)등은 gmail이나 fastmail에서 찾아보면 자세한 문서가 있다. 대동 소이하다. smtp로 접속하면 매번 login을 해야 한다. username과 password를 입력해야 한다. 그래서 login을 자동으로 해주는     (setq message-send-mail-function 'smtpmail-send-it)을 기술 한다. 이건 .authinfo라는 파일에 기술된 id와 pw을 자동으로 입력해준다. .authinfo는 text file이라서 보안에 취약하기 때문에 gpg로 암호화한다. gpg --generate-all-key를 하면 public key와 private key를 만들 수 있다. 만들때 pass phrase를 입력해서 key에 대한 접근을 쉽게 할 수 있다. 여튼 .authinfo에 규정에 맞는 id,pw를 입력하고  gpg로 encrypt하면 된다. id와 pw는 fastmail의 경우 id의 경우 id만 입력하진 않는다. 그리고 password를 app password를 사용한다. 반면 gmail은 id와 pw 모두 web에서 login할때와 동일하다. Imap에서 mail을 다운받을 때 mbsync를 사용했고, 거기에도 logic(access)해야 하는데, . mbsyncrc에 id와 pw를 명기하는데, 그 때도 fastmail은 app password를 사용했었다.
:end: 
#+begin_src emacs-lisp
  (use-package org-mime
    :ensure t
    :config
    (setq org-mime-export-options '(:section-numbers nil
                                    :with-author nil
                                    :with-toc nil))
    ;; (add-hook 'message-send-hook 'org-mime-htmlize)
    (add-hook 'message-send-hook 'org-mime-confirm-when-no-multipart)

    (add-hook 'org-mime-html-hook
       (lambda ()
          (org-mime-change-element-style
           "pre" (format "color: %s; background-color: %s; padding: 0.5em;"
                         "#E6E1DC" "#232323"))))
  )
#+end_src
:org_with_email:
email의 body는 plain text이다. 이것을 html포맷으로 바꿀 수 있다. html포맷으로 바꾼다는 것은 link를 사용할 수 있고, image,code block, formatted text를 사용할 수 있다는 장점이 있다.

org-mime의 여러 함수를 사용해서 org와 html관련 여러 처리가 가능하다.

1) mu4e에서 org 문서 작성후 htmlize해서 보내기
   - mu4e Compose mail에서 org로 글 작성 -> org-mime-htmlize해서 보낸다.
   - mu4e Compose mail에서 editer buffer로 org buffer를 open한다.
     M-x org-mime-edit-mail-in-org-mode를 실행하면 org buffer가 생긴다. 더많은 org 기능을 사용할 수 있다. 다 작성후에 C-c C-c를 누르고 org-mime-htmlize해서 보낸다.

2) org-mime-org-buffer-htmlize
   - org buffer를 html로 변경한다. org buffer에서 M-x org-mime org-buffer-htmlize 하면 compose창이 뜨고 바로 email로 전송할 수 있게 된다. org-mime-org-buffer-htmlize는 단지 org buffer를 html buffer로 변환했기 때문에 단지 plain buffer라고 한다.  그래서 mu4e buffer가 갖는 기능들, 예를 들면 email address입력시 자동 입력이 안되는 것이 있을 수 있다고 한다. 이것을 해주기 위해서 M-x mu4e-compose-mode로 바꿔야 한다고 하는데, 내경우는 그럴 필요가 없었다.

3) org-mime-org-subtree-htmlize
   - org mode의 heading은 그 자체가 하나의 subtree다. org buffer에서 하나의 heading에 cursor를 두고 M-x org-mime-org-subtree-htmlize를 하면 해당 헤더를 title로 하는  메일로 보낼 수 있다.

4) org buffer를 htmlize한 후 email 보낼때 문제점
   - section이 보여서 이상하다.
   - toc이 보여서 이상하다.
   - author가 보여서 이상하다. 
=> 이것을 해결하기 위해서 org-mime-export-option을 추가한다.

5) org-mime-confirm-when-no-multipart
mu4e에서 작성하는 text는 plain text다. org로 작성해도 plain text다. 다양한 기능을 사용하는 html로 바꾸기 위해서는 매번 mail을 작성하고 org-mime-htmlize를 해줘야한다. 이것을 자동으로 할수도 있다. 하지만, 가끔은 plain text를 필요로 하는 경우가 있기 때문에 경고창만 보내고 수동으로 org-mime-htmlize를 하는 방식을 추천한다.
:end:
:org-capture_mail:
[[https://github.com/daviwil/emacs-from-scratch/blob/master/show-notes/Emacs-Mail-05.org][참조]]
- mu4e-org(org capture %a)
mail도 해야할 일 list에 넣어서 관리할 수 있다. org mode라는게 원래 orgnize에서 왔기 때문에, 즉 일정관리다. 그중 email도 관리 대상이 될 수 있다. mail을 todo 리스트로 넣어서 관리할 수있다. 이렇게 하기위해서는 mu4e의 헤더뷰(mail list)에서 특정 메일에 cursor를 올려놓고 org-capture를 하면 todo list를 만든다.(%a)
org-capture로 만들어진 todo 가 저장될 곳은  ~/Org/Mail.org다. Org관련한 문서는  Org-directory라는 변수에 지정할 수 있는데, 지정하게 되면 Org관련 명령에서 Org문서 관련 참조가 해당 디렉토리에서 찾게된다.

- org capture %i
org-capture에서 %i를 넣으면 mu4e 헤더뷰에서 메일을 읽고 특정 문장을 block으로 지정한후 org-capture를 하면 해당 block이 todo list에 들어간다.

- 여러가지 option
%:subject
%:from
%:fromname
%:to,%:toname
%:date 

- schedule과 deadline
schedule은 to do time, deadline은 to be done time이다. 스케쥴은 시작일이라고 보면 된다. project가 6월3에 스케쥴되었다는건 그때 시작한다는 뜻이다. 생일축하 파티가 6월 9일이면 그 때 시작한다는 것이다. 반드시 deadline이 있는 건 아니다. project나 task에 따라 어떤 것들은 schedule만 있고, 어떤 것은 deadline만 있고, 또 다른 어떤 것은 schedule과 deadline이 같이 있다.
1) schedule: %t
2) deadline: org-read-date란 함수를 사용해서 자동으로 +2일에 끝나게 설정할 수 있다.

- agenda file에 추가
org/mail.org를 agenda file에 추가해야만 agenda로 관리 할 수 있다.

- quick action
mu4e에서 mail을 읽고 이것을 해야할일(todo)라고 판단하면 org-capture를 실행해서 org/mails.org의 todo list로 넘기는 작업을 했었는데, header view(mail list)에서 간단히 제목만 보고 to do list로 넘길수 있다. 메일을 읽지않고도 메일 제목만 보고 해야 할일로 넘길 수 있다는 것이다. 그런데 보통의 처리과정은 다음과 같다. 오늘 메일을 다 읽는다. 그리고 header view에서 처리한다. 이렇게 header view에서 처리하기 위해서는 immedietly finish를 세팅해야 한다.
 :end:
** org-alert
#+begin_src emacs-lisp
  ;; (use-package alert
  ;;   :ensure t)
  ;; (use-package org-alert
  ;; :custom (alert-default-style 'notifications)
  ;; :config
  ;; (setq org-alert-interval 300
  ;;       org-alert-notification-title "org alert reminder!")
  ;; (org-alert-enable))
#+end_src
** org presentation
#+begin_src emacs-lisp
;(use-package org-tree-slide
;  :custom
;  (org-image-actual-width nil))

#+end_src
